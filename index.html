<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>홍원 테트리스 (파스텔 톤)</title>
    <style>
        /* 1. CSS: 스타일 및 파스텔 톤 정의 */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #36454F; /* 짙은 배경 */
            margin: 0;
            font-family: 'Malgun Gothic', 'Arial', sans-serif;
            flex-direction: column;
        }

        #score {
            color: #E6E6FA; /* 연한 자주색 계열 */
            margin-bottom: 20px; 
            font-size: 2.2em;
            font-weight: bold;
            text-shadow: 2px 2px #483D8B;
        }

        #game-container {
            border: 8px solid #E0B0FF; /* 라벤더색 테두리 */
            background-color: #1a1a2e; /* 어두운 게임 배경 */
            display: inline-block;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 1px;
        }

        .cell {
            width: 30px;
            height: 30px;
            background-color: #111;
            box-sizing: border-box;
            border: 1px solid #000;
            
            /* 텍스트 중앙 정렬 설정 */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #222; /* 텍스트 색상 */
            font-size: 0.7em;
            font-weight: bold;
            padding: 0;
            margin: 0;
            /* 텍스트가 너무 길면 잘리도록 숨김 */
            overflow: hidden; 
        }

        /* 2. 파스텔 톤 블록 색상 클래스 */
        .T { background-color: #B57EDC; border: 1px solid #9370DB; }
        .L { background-color: #FFB7C5; border: 1px solid #FF9DBF; }
        .J { background-color: #ADD8E6; border: 1px solid #87CEEB; }
        .I { background-color: #AFEEEE; border: 1px solid #7FFFD4; }
        .O { background-color: #FFFF99; border: 1px solid #FFFF66; }
        .S { background-color: #98FB98; border: 1px solid #7CFC00; }
        .Z { background-color: #FFC0CB; border: 1px solid #FF69B4; }

        .controls {
            color: #E6E6FA;
            margin-top: 15px;
            font-size: 1em;
        }
    </style>
</head>
<body>

    <div id="score">점수: 0</div> 

    <div id="game-container">
        <div id="game-board">
            </div>
    </div>
    
    <div class="controls">
        <p>키보드: ←, → (이동), ↓ (빠른 하강)</p>
        <p style="font-size: 0.9em; color: #aaa;">(하강 속도: 1.5초로 난이도 하향됨)</p>
    </div>

    <script>
        // 3. JavaScript: 로직

        // 게임 설정
        const COLS = 10;
        const ROWS = 20;
        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');

        // 게임 상태 배열
        let board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
        let cells = []; 

        // 현재 움직이는 블록
        let currentPiece;
        let currentX = 0;
        let currentY = 0;
        let score = 0;
        let gameInterval;
        let speed = 1500; // 난이도: 1.5초 (느린 속도)

        const TETROMINOES = [
            { shape: [[0,1,1], [1,1,0], [0,0,0]], color: 'S' },
            { shape: [[1,1,0], [0,1,1], [0,0,0]], color: 'Z' },
            { shape: [[1,0,0], [1,1,1], [0,0,0]], color: 'J' },
            { shape: [[0,0,1], [1,1,1], [0,0,0]], color: 'L' },
            { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: 'I' },
            { shape: [[1,1], [1,1]], color: 'O' },
            { shape: [[0,1,0], [1,1,1], [0,0,0]], color: 'T' }
        ];

        // --- 초기화 및 상태 함수 ---

        function createBoard() {
            for (let r = 0; r < ROWS; r++) {
                cells[r] = [];
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    boardElement.appendChild(cell);
                    cells[r][c] = cell;
                }
            }
        }
        
        function updateScore() {
            scoreElement.textContent = `점수: ${score}`;
        }

        function newPiece() {
            const randomIndex = Math.floor(Math.random() * TETROMINOES.length);
            currentPiece = JSON.parse(JSON.stringify(TETROMINOES[randomIndex]));
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentY = 0;

            if (!isValidMove(currentPiece.shape, currentX, currentY)) {
                clearInterval(gameInterval);
                alert('Game Over! 최종 점수: ' + score);
            }
        }
        
        function isValidMove(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newX = x + c;
                        const newY = y + r;

                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return false;
                        }
                        if (newY >= 0 && board[newY][newX] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // --- 렌더링 함수 (홍원 텍스트 로직) ---

        // 현재 블록을 보드에서 제거 (이동 전 상태)
        function clearPiece() {
            if (currentPiece) {
                const shape = currentPiece.shape;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const y = currentY + r;
                            const x = currentX + c;
                            if (y >= 0) {
                                cells[y][x].className = 'cell';
                                cells[y][x].textContent = ''; 
                            }
                        }
                    }
                }
            }
        }

        // 현재 움직이는 블록을 보드에 그리기 ('홍원' 텍스트 적용)
        function drawPiece() {
            if (currentPiece) {
                const shape = currentPiece.shape;
                const color = currentPiece.color;
                
                let textIndex = 0;
                const text = '홍원';
                
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const y = currentY + r;
                            const x = currentX + c;
                            if (y >= 0) {
                                // 1. 색상 및 기본 클래스 적용
                                cells[y][x].className = `cell ${color}`;

                                // 2. 텍스트 적용: '홍' 또는 '원'을 순서대로 넣고 나머지는 반복
                                cells[y][x].textContent = text[textIndex % text.length];
                                textIndex++;
                            }
                        }
                    }
                }
            }
        }

        // 고정된 블록과 현재 블록 모두를 화면에 업데이트
        function redrawBoard() {
            // 1. 고정된 블록(board 배열) 그리기 (색상만)
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cellValue = board[r][c];
                    const colorClass = cellValue === 0 ? '' : TETROMINOES[cellValue - 1].color; 
                    
                    cells[r][c].className = `cell ${colorClass}`;
                    cells[r][c].textContent = ''; // 고정 블록 텍스트 제거
                }
            }
            // 2. 현재 움직이는 블록 그리기 (텍스트 적용)
            drawPiece();
            // 3. 점수 업데이트
            updateScore(); 
        }

        // --- 게임 로직 함수 ---

        function lockPiece() {
            const shape = currentPiece.shape;
            const pieceIndex = TETROMINOES.findIndex(t => t.color === currentPiece.color) + 1;

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const y = currentY + r;
                        const x = currentX + c;
                        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                            board[y][x] = pieceIndex;
                        }
                    }
                }
            }
            // TODO: 줄 제거 및 점수 업데이트 로직 추가 필요

            newPiece();
        }

        // 메인 게임 루프 (블록 자동 하강)
        function gameLoop() {
            clearPiece();

            if (isValidMove(currentPiece.shape, currentX, currentY + 1)) {
                currentY++;
            } else {
                lockPiece();
            }
            
            redrawBoard();
        }

        // --- 이벤트 핸들러 ---

        document.addEventListener('keydown', (e) => {
            clearPiece();
            let newX = currentX;
            let newY = currentY;

            if (e.key === 'ArrowLeft') {
                newX--;
            } else if (e.key === 'ArrowRight') {
                newX++;
            } else if (e.key === 'ArrowDown') {
                newY++;
            }
            // TODO: 회전 로직 (ArrowUp) 추가 필요
            
            if (isValidMove(currentPiece.shape, newX, newY)) {
                currentX = newX;
                currentY = newY;
            } else if (e.key === 'ArrowDown') {
                 // 아래로 이동 불가 시 즉시 고정
                 lockPiece();
            }

            redrawBoard();
        });


        // --- 게임 시작 ---
        createBoard();
        updateScore();
        newPiece();
        gameInterval = setInterval(gameLoop, speed);

    </script>
</body>
</html>
